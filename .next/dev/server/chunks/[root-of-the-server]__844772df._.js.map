{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/pius_rego/Smart-AI-API-Mocking-Tool/src/lib/storage.ts"],"sourcesContent":["import { MockEndpoint } from \"./types\";\n\n// In-memory storage for mock endpoints\n// In production, you'd use a database like MongoDB, PostgreSQL, or Redis\nclass MockStorage {\n  private endpoints: Map<string, MockEndpoint> = new Map();\n\n  create(endpoint: MockEndpoint): MockEndpoint {\n    this.endpoints.set(endpoint.id, endpoint);\n    return endpoint;\n  }\n\n  getById(id: string): MockEndpoint | undefined {\n    return this.endpoints.get(id);\n  }\n\n  getBySlug(slug: string): MockEndpoint | undefined {\n    for (const endpoint of this.endpoints.values()) {\n      if (endpoint.slug === slug) {\n        return endpoint;\n      }\n    }\n    return undefined;\n  }\n\n  update(id: string, updates: Partial<MockEndpoint>): MockEndpoint | undefined {\n    const existing = this.endpoints.get(id);\n    if (!existing) return undefined;\n\n    const updated = {\n      ...existing,\n      ...updates,\n      updatedAt: new Date().toISOString(),\n    };\n    this.endpoints.set(id, updated);\n    return updated;\n  }\n\n  delete(id: string): boolean {\n    return this.endpoints.delete(id);\n  }\n\n  getAll(): MockEndpoint[] {\n    return Array.from(this.endpoints.values()).sort(\n      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n    );\n  }\n\n  clear(): void {\n    this.endpoints.clear();\n  }\n}\n\n// Singleton instance\nexport const mockStorage = new MockStorage();\n"],"names":[],"mappings":";;;;AAEA,uCAAuC;AACvC,yEAAyE;AACzE,MAAM;IACI,YAAuC,IAAI,MAAM;IAEzD,OAAO,QAAsB,EAAgB;QAC3C,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE;QAChC,OAAO;IACT;IAEA,QAAQ,EAAU,EAA4B;QAC5C,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC;IAC5B;IAEA,UAAU,IAAY,EAA4B;QAChD,KAAK,MAAM,YAAY,IAAI,CAAC,SAAS,CAAC,MAAM,GAAI;YAC9C,IAAI,SAAS,IAAI,KAAK,MAAM;gBAC1B,OAAO;YACT;QACF;QACA,OAAO;IACT;IAEA,OAAO,EAAU,EAAE,OAA8B,EAA4B;QAC3E,MAAM,WAAW,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC;QACpC,IAAI,CAAC,UAAU,OAAO;QAEtB,MAAM,UAAU;YACd,GAAG,QAAQ;YACX,GAAG,OAAO;YACV,WAAW,IAAI,OAAO,WAAW;QACnC;QACA,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI;QACvB,OAAO;IACT;IAEA,OAAO,EAAU,EAAW;QAC1B,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;IAC/B;IAEA,SAAyB;QACvB,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,IAAI,CAC7C,CAAC,GAAG,IAAM,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO;IAE7E;IAEA,QAAc;QACZ,IAAI,CAAC,SAAS,CAAC,KAAK;IACtB;AACF;AAGO,MAAM,cAAc,IAAI"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///Users/pius_rego/Smart-AI-API-Mocking-Tool/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function generateEndpointSlug(prompt: string): string {\n  // Extract meaningful words and create a slug\n  const words = prompt\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, \"\")\n    .split(/\\s+/)\n    .filter((word) => word.length > 2)\n    .slice(0, 3);\n\n  return words.join(\"-\") + \"-\" + Math.random().toString(36).substring(2, 8);\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function shouldFail(errorRate: number): boolean {\n  return Math.random() * 100 < errorRate;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,wKAAO,EAAC,IAAA,+IAAI,EAAC;AACtB;AAEO,SAAS,qBAAqB,MAAc;IACjD,6CAA6C;IAC7C,MAAM,QAAQ,OACX,WAAW,GACX,OAAO,CAAC,gBAAgB,IACxB,KAAK,CAAC,OACN,MAAM,CAAC,CAAC,OAAS,KAAK,MAAM,GAAG,GAC/B,KAAK,CAAC,GAAG;IAEZ,OAAO,MAAM,IAAI,CAAC,OAAO,MAAM,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;AACzE;AAEO,SAAS,MAAM,EAAU;IAC9B,OAAO,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;AACtD;AAEO,SAAS,WAAW,SAAiB;IAC1C,OAAO,KAAK,MAAM,KAAK,MAAM;AAC/B"}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":["file:///Users/pius_rego/Smart-AI-API-Mocking-Tool/src/lib/types.ts"],"sourcesContent":["export interface MockEndpoint {\n  id: string;\n  slug: string;\n  name: string;\n  prompt: string;\n  schema: Record<string, unknown>;\n  data: unknown;\n  createdAt: string;\n  updatedAt: string;\n  settings: EndpointSettings;\n}\n\nexport interface EndpointSettings {\n  // Chaos Mode settings\n  latency: number; // milliseconds of delay\n  errorRate: number; // percentage of requests that should fail (0-100)\n  errorType: \"500\" | \"503\" | \"404\" | \"timeout\";\n\n  // Dynamic routing settings\n  supportedMethods: HttpMethod[];\n  \n  // Response customization\n  customHeaders: Record<string, string>;\n}\n\nexport type HttpMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n\nexport interface GenerateRequest {\n  prompt: string;\n}\n\nexport interface GenerateResponse {\n  success: boolean;\n  endpoint?: MockEndpoint;\n  error?: string;\n}\n\nexport interface MockResponse {\n  success: boolean;\n  data?: unknown;\n  message?: string;\n  timestamp: string;\n  method: HttpMethod;\n  simulatedLatency?: number;\n}\n\nexport interface ChaosConfig {\n  latency: number;\n  errorRate: number;\n  errorType: \"500\" | \"503\" | \"404\" | \"timeout\";\n}\n\nexport const DEFAULT_SETTINGS: EndpointSettings = {\n  latency: 0,\n  errorRate: 0,\n  errorType: \"500\",\n  supportedMethods: [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"],\n  customHeaders: {},\n};\n\nexport const ERROR_RESPONSES = {\n  \"500\": {\n    status: 500,\n    message: \"Internal Server Error - The server encountered an unexpected condition.\",\n  },\n  \"503\": {\n    status: 503,\n    message: \"Service Unavailable - The server is temporarily unable to handle the request.\",\n  },\n  \"404\": {\n    status: 404,\n    message: \"Not Found - The requested resource could not be found.\",\n  },\n  timeout: {\n    status: 408,\n    message: \"Request Timeout - The server timed out waiting for the request.\",\n  },\n};\n"],"names":[],"mappings":";;;;;;AAoDO,MAAM,mBAAqC;IAChD,SAAS;IACT,WAAW;IACX,WAAW;IACX,kBAAkB;QAAC;QAAO;QAAQ;QAAO;QAAS;KAAS;IAC3D,eAAe,CAAC;AAClB;AAEO,MAAM,kBAAkB;IAC7B,OAAO;QACL,QAAQ;QACR,SAAS;IACX;IACA,OAAO;QACL,QAAQ;QACR,SAAS;IACX;IACA,OAAO;QACL,QAAQ;QACR,SAAS;IACX;IACA,SAAS;QACP,QAAQ;QACR,SAAS;IACX;AACF"}},
    {"offset": {"line": 168, "column": 0}, "map": {"version":3,"sources":["file:///Users/pius_rego/Smart-AI-API-Mocking-Tool/src/app/api/mock/%5Bslug%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { mockStorage } from \"@/lib/storage\";\nimport { sleep, shouldFail } from \"@/lib/utils\";\nimport { ERROR_RESPONSES, HttpMethod, MockResponse } from \"@/lib/types\";\n\n// This is the dynamic mock endpoint handler\n// It supports all HTTP methods and implements Chaos Mode\n\nasync function handleMockRequest(\n  request: NextRequest,\n  slug: string,\n  method: HttpMethod\n) {\n  try {\n    const endpoint = mockStorage.getBySlug(slug);\n\n    if (!endpoint) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: \"Mock endpoint not found\",\n          message: `No mock endpoint exists with slug: ${slug}`,\n        },\n        { status: 404 }\n      );\n    }\n\n    // Check if the method is supported\n    if (!endpoint.settings.supportedMethods.includes(method)) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: \"Method not allowed\",\n          message: `This endpoint does not support ${method} requests`,\n          supportedMethods: endpoint.settings.supportedMethods,\n        },\n        { status: 405 }\n      );\n    }\n\n    // === CHAOS MODE: Latency Simulation ===\n    if (endpoint.settings.latency > 0) {\n      await sleep(endpoint.settings.latency);\n    }\n\n    // === CHAOS MODE: Error Rate Simulation ===\n    if (shouldFail(endpoint.settings.errorRate)) {\n      const errorInfo = ERROR_RESPONSES[endpoint.settings.errorType];\n      return NextResponse.json(\n        {\n          success: false,\n          error: errorInfo.message,\n          simulatedError: true,\n          errorType: endpoint.settings.errorType,\n          timestamp: new Date().toISOString(),\n        },\n        { status: errorInfo.status }\n      );\n    }\n\n    // === DYNAMIC ROUTING: Handle different HTTP methods ===\n    let responseData: MockResponse;\n    let body: unknown = null;\n\n    // Parse body for methods that support it\n    if ([\"POST\", \"PUT\", \"PATCH\"].includes(method)) {\n      try {\n        body = await request.json();\n      } catch {\n        // Body might be empty or not JSON\n        body = null;\n      }\n    }\n\n    switch (method) {\n      case \"GET\":\n        responseData = {\n          success: true,\n          data: endpoint.data,\n          message: \"Data retrieved successfully\",\n          timestamp: new Date().toISOString(),\n          method,\n          simulatedLatency: endpoint.settings.latency,\n        };\n        break;\n\n      case \"POST\":\n        // Simulate creating a new resource\n        responseData = {\n          success: true,\n          data: {\n            id: crypto.randomUUID(),\n            ...((body as object) || {}),\n            createdAt: new Date().toISOString(),\n          },\n          message: \"Resource created successfully\",\n          timestamp: new Date().toISOString(),\n          method,\n          simulatedLatency: endpoint.settings.latency,\n        };\n        break;\n\n      case \"PUT\":\n      case \"PATCH\":\n        // Simulate updating a resource\n        responseData = {\n          success: true,\n          data: {\n            ...((body as object) || {}),\n            updatedAt: new Date().toISOString(),\n          },\n          message: `Resource ${method === \"PUT\" ? \"replaced\" : \"updated\"} successfully`,\n          timestamp: new Date().toISOString(),\n          method,\n          simulatedLatency: endpoint.settings.latency,\n        };\n        break;\n\n      case \"DELETE\":\n        // Simulate deleting a resource\n        responseData = {\n          success: true,\n          data: null,\n          message: \"Resource deleted successfully\",\n          timestamp: new Date().toISOString(),\n          method,\n          simulatedLatency: endpoint.settings.latency,\n        };\n        break;\n\n      default:\n        return NextResponse.json(\n          { success: false, error: \"Method not supported\" },\n          { status: 405 }\n        );\n    }\n\n    // Build response with custom headers\n    const response = NextResponse.json(responseData);\n\n    // Add custom headers if configured\n    if (endpoint.settings.customHeaders) {\n      for (const [key, value] of Object.entries(endpoint.settings.customHeaders)) {\n        response.headers.set(key, value);\n      }\n    }\n\n    // Add CORS headers for easy frontend testing\n    response.headers.set(\"Access-Control-Allow-Origin\", \"*\");\n    response.headers.set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, PATCH, DELETE, OPTIONS\");\n    response.headers.set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\");\n\n    return response;\n  } catch (error) {\n    console.error(\"Mock endpoint error:\", error);\n    return NextResponse.json(\n      { success: false, error: \"Internal server error\" },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ slug: string }> }\n) {\n  const { slug } = await params;\n  return handleMockRequest(request, slug, \"GET\");\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ slug: string }> }\n) {\n  const { slug } = await params;\n  return handleMockRequest(request, slug, \"POST\");\n}\n\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: Promise<{ slug: string }> }\n) {\n  const { slug } = await params;\n  return handleMockRequest(request, slug, \"PUT\");\n}\n\nexport async function PATCH(\n  request: NextRequest,\n  { params }: { params: Promise<{ slug: string }> }\n) {\n  const { slug } = await params;\n  return handleMockRequest(request, slug, \"PATCH\");\n}\n\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ slug: string }> }\n) {\n  const { slug } = await params;\n  return handleMockRequest(request, slug, \"DELETE\");\n}\n\nexport async function OPTIONS() {\n  return new NextResponse(null, {\n    status: 204,\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, POST, PUT, PATCH, DELETE, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,4CAA4C;AAC5C,yDAAyD;AAEzD,eAAe,kBACb,OAAoB,EACpB,IAAY,EACZ,MAAkB;IAElB,IAAI;QACF,MAAM,WAAW,sIAAW,CAAC,SAAS,CAAC;QAEvC,IAAI,CAAC,UAAU;YACb,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO;gBACP,SAAS,CAAC,mCAAmC,EAAE,MAAM;YACvD,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,mCAAmC;QACnC,IAAI,CAAC,SAAS,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,CAAC,SAAS;YACxD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO;gBACP,SAAS,CAAC,+BAA+B,EAAE,OAAO,SAAS,CAAC;gBAC5D,kBAAkB,SAAS,QAAQ,CAAC,gBAAgB;YACtD,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,yCAAyC;QACzC,IAAI,SAAS,QAAQ,CAAC,OAAO,GAAG,GAAG;YACjC,MAAM,IAAA,8HAAK,EAAC,SAAS,QAAQ,CAAC,OAAO;QACvC;QAEA,4CAA4C;QAC5C,IAAI,IAAA,mIAAU,EAAC,SAAS,QAAQ,CAAC,SAAS,GAAG;YAC3C,MAAM,YAAY,wIAAe,CAAC,SAAS,QAAQ,CAAC,SAAS,CAAC;YAC9D,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO,UAAU,OAAO;gBACxB,gBAAgB;gBAChB,WAAW,SAAS,QAAQ,CAAC,SAAS;gBACtC,WAAW,IAAI,OAAO,WAAW;YACnC,GACA;gBAAE,QAAQ,UAAU,MAAM;YAAC;QAE/B;QAEA,yDAAyD;QACzD,IAAI;QACJ,IAAI,OAAgB;QAEpB,yCAAyC;QACzC,IAAI;YAAC;YAAQ;YAAO;SAAQ,CAAC,QAAQ,CAAC,SAAS;YAC7C,IAAI;gBACF,OAAO,MAAM,QAAQ,IAAI;YAC3B,EAAE,OAAM;gBACN,kCAAkC;gBAClC,OAAO;YACT;QACF;QAEA,OAAQ;YACN,KAAK;gBACH,eAAe;oBACb,SAAS;oBACT,MAAM,SAAS,IAAI;oBACnB,SAAS;oBACT,WAAW,IAAI,OAAO,WAAW;oBACjC;oBACA,kBAAkB,SAAS,QAAQ,CAAC,OAAO;gBAC7C;gBACA;YAEF,KAAK;gBACH,mCAAmC;gBACnC,eAAe;oBACb,SAAS;oBACT,MAAM;wBACJ,IAAI,OAAO,UAAU;wBACrB,GAAI,AAAC,QAAmB,CAAC,CAAC;wBAC1B,WAAW,IAAI,OAAO,WAAW;oBACnC;oBACA,SAAS;oBACT,WAAW,IAAI,OAAO,WAAW;oBACjC;oBACA,kBAAkB,SAAS,QAAQ,CAAC,OAAO;gBAC7C;gBACA;YAEF,KAAK;YACL,KAAK;gBACH,+BAA+B;gBAC/B,eAAe;oBACb,SAAS;oBACT,MAAM;wBACJ,GAAI,AAAC,QAAmB,CAAC,CAAC;wBAC1B,WAAW,IAAI,OAAO,WAAW;oBACnC;oBACA,SAAS,CAAC,SAAS,EAAE,WAAW,QAAQ,aAAa,UAAU,aAAa,CAAC;oBAC7E,WAAW,IAAI,OAAO,WAAW;oBACjC;oBACA,kBAAkB,SAAS,QAAQ,CAAC,OAAO;gBAC7C;gBACA;YAEF,KAAK;gBACH,+BAA+B;gBAC/B,eAAe;oBACb,SAAS;oBACT,MAAM;oBACN,SAAS;oBACT,WAAW,IAAI,OAAO,WAAW;oBACjC;oBACA,kBAAkB,SAAS,QAAQ,CAAC,OAAO;gBAC7C;gBACA;YAEF;gBACE,OAAO,gJAAY,CAAC,IAAI,CACtB;oBAAE,SAAS;oBAAO,OAAO;gBAAuB,GAChD;oBAAE,QAAQ;gBAAI;QAEpB;QAEA,qCAAqC;QACrC,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC;QAEnC,mCAAmC;QACnC,IAAI,SAAS,QAAQ,CAAC,aAAa,EAAE;YACnC,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,SAAS,QAAQ,CAAC,aAAa,EAAG;gBAC1E,SAAS,OAAO,CAAC,GAAG,CAAC,KAAK;YAC5B;QACF;QAEA,6CAA6C;QAC7C,SAAS,OAAO,CAAC,GAAG,CAAC,+BAA+B;QACpD,SAAS,OAAO,CAAC,GAAG,CAAC,gCAAgC;QACrD,SAAS,OAAO,CAAC,GAAG,CAAC,gCAAgC;QAErD,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAAwB,GACjD;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAyC;IAEjD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM;IACvB,OAAO,kBAAkB,SAAS,MAAM;AAC1C;AAEO,eAAe,KACpB,OAAoB,EACpB,EAAE,MAAM,EAAyC;IAEjD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM;IACvB,OAAO,kBAAkB,SAAS,MAAM;AAC1C;AAEO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAyC;IAEjD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM;IACvB,OAAO,kBAAkB,SAAS,MAAM;AAC1C;AAEO,eAAe,MACpB,OAAoB,EACpB,EAAE,MAAM,EAAyC;IAEjD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM;IACvB,OAAO,kBAAkB,SAAS,MAAM;AAC1C;AAEO,eAAe,OACpB,OAAoB,EACpB,EAAE,MAAM,EAAyC;IAEjD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM;IACvB,OAAO,kBAAkB,SAAS,MAAM;AAC1C;AAEO,eAAe;IACpB,OAAO,IAAI,gJAAY,CAAC,MAAM;QAC5B,QAAQ;QACR,SAAS;YACP,+BAA+B;YAC/B,gCAAgC;YAChC,gCAAgC;QAClC;IACF;AACF"}}]
}